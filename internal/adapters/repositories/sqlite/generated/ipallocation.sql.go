// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ipallocation.sql

package sqlc

import (
	"context"
)

const getNextCandidate = `-- name: GetNextCandidate :one
SELECT next_candidate FROM ip_allocator_state WHERE prefix = ?
`

func (q *Queries) GetNextCandidate(ctx context.Context, prefix string) (string, error) {
	row := q.db.QueryRowContext(ctx, getNextCandidate, prefix)
	var next_candidate string
	err := row.Scan(&next_candidate)
	return next_candidate, err
}

const getReleasedIP = `-- name: GetReleasedIP :one
SELECT ip FROM ip_allocations
WHERE prefix = ? AND released_at IS NOT NULL
ORDER BY released_at ASC LIMIT 1
`

func (q *Queries) GetReleasedIP(ctx context.Context, prefix string) (string, error) {
	row := q.db.QueryRowContext(ctx, getReleasedIP, prefix)
	var ip string
	err := row.Scan(&ip)
	return ip, err
}

const isAllocated = `-- name: IsAllocated :one
SELECT COUNT(*) FROM ip_allocations
WHERE ip = ? AND released_at IS NULL
`

func (q *Queries) IsAllocated(ctx context.Context, ip string) (int64, error) {
	row := q.db.QueryRowContext(ctx, isAllocated, ip)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const release = `-- name: Release :exec
UPDATE ip_allocations
SET released_at = CURRENT_TIMESTAMP
WHERE ip = ? AND released_at IS NULL
`

func (q *Queries) Release(ctx context.Context, ip string) error {
	_, err := q.db.ExecContext(ctx, release, ip)
	return err
}

const releaseByPublicKey = `-- name: ReleaseByPublicKey :exec
UPDATE ip_allocations 
SET released_at = CURRENT_TIMESTAMP 
WHERE pubkey = ? AND released_at IS NULL
`

func (q *Queries) ReleaseByPublicKey(ctx context.Context, pubkey string) error {
	_, err := q.db.ExecContext(ctx, releaseByPublicKey, pubkey)
	return err
}

const releaseIP = `-- name: ReleaseIP :exec
UPDATE ip_allocations
SET released_at = NULL, allocated_at = CURRENT_TIMESTAMP
WHERE ip = ?
`

func (q *Queries) ReleaseIP(ctx context.Context, ip string) error {
	_, err := q.db.ExecContext(ctx, releaseIP, ip)
	return err
}

const reserve = `-- name: Reserve :exec
INSERT INTO ip_allocations (ip, pubkey, prefix)
VALUES (?, ?, ?)
ON CONFLICT(ip) DO UPDATE SET
    pubkey       = excluded.pubkey,
    prefix       = excluded.prefix,
    allocated_at = CURRENT_TIMESTAMP,
    released_at  = NULL
`

type ReserveParams struct {
	Ip     string
	Pubkey string
	Prefix string
}

func (q *Queries) Reserve(ctx context.Context, arg ReserveParams) error {
	_, err := q.db.ExecContext(ctx, reserve, arg.Ip, arg.Pubkey, arg.Prefix)
	return err
}

const updateNextCandidate = `-- name: UpdateNextCandidate :exec
INSERT INTO ip_allocator_state (prefix, next_candidate) VALUES (?, ?)
ON CONFLICT(prefix) DO UPDATE SET next_candidate = excluded.next_candidate
`

type UpdateNextCandidateParams struct {
	Prefix        string
	NextCandidate string
}

func (q *Queries) UpdateNextCandidate(ctx context.Context, arg UpdateNextCandidateParams) error {
	_, err := q.db.ExecContext(ctx, updateNextCandidate, arg.Prefix, arg.NextCandidate)
	return err
}
